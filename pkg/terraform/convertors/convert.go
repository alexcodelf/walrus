package convertors

import (
	"context"
	"fmt"

	"github.com/seal-io/utils/stringx"
	"k8s.io/apimachinery/pkg/util/sets"

	walruscore "github.com/seal-io/walrus/pkg/apis/walruscore/v1"
	"github.com/seal-io/walrus/pkg/terraform/block"
	"github.com/seal-io/walrus/pkg/terraform/convertor"
	"github.com/seal-io/walrus/pkg/terraform/convertors/alibaba"
	"github.com/seal-io/walrus/pkg/terraform/convertors/aws"
	"github.com/seal-io/walrus/pkg/terraform/convertors/azurerm"
	_default "github.com/seal-io/walrus/pkg/terraform/convertors/default"
	"github.com/seal-io/walrus/pkg/terraform/convertors/docker"
	"github.com/seal-io/walrus/pkg/terraform/convertors/google"
	"github.com/seal-io/walrus/pkg/terraform/convertors/helm"
	"github.com/seal-io/walrus/pkg/terraform/convertors/k8s"
	"github.com/seal-io/walrus/pkg/terraform/convertors/kubectl"
)

const (
	TypeKubernetes = "kubernetes"
	TypeHelm       = "helm"
	TypeKubectl    = "kubectl"
	TypeAliCloud   = "alicloud"
	TypeAWS        = "aws"
	TypeAzureRM    = "azurerm"
	TypeGoogle     = "google"
	TypeDocker     = "docker"
	// Add more convertor type.
)

// supportedProviders is the supported provider types,
// it is used to validate the required providers.
var supportedProviders = []string{
	TypeKubernetes,
	TypeHelm,
	TypeKubectl,
	TypeAliCloud,
	TypeAWS,
	TypeAzureRM,
	TypeGoogle,
	// Add more convertor type.
}

// LoadConvertor loads the convertor by the provider type.
func LoadConvertor(provider string) convertor.Convertor {
	switch provider {
	case TypeKubernetes:
		return k8s.K8sConvertor(provider)
	case TypeHelm:
		return helm.HelmConvertor(provider)
	case TypeKubectl:
		return kubectl.KubectlConvertor(provider)
	case TypeAliCloud:
		return alibaba.AlibabaConvertor(provider)
	case TypeAWS:
		return aws.AWSConvertor(provider)
	case TypeAzureRM:
		return azurerm.AzureRMConvertor(provider)
	case TypeGoogle:
		return google.GoogleConvertor(provider)
	case TypeDocker:
		return docker.DockerConvertor(provider)
	default:
		return _default.DefaultConvertor(provider)
	}
}

// ToProvidersBlocks converts the connectors to provider blocks with required providers.
func ToProvidersBlocks(
	ctx context.Context,
	providers []string,
	connectors walruscore.Connectors,
	opts convertor.ConvertOptions,
) (blocks block.Blocks, err error) {
	for _, p := range providers {
		var convertBlocks block.Blocks

		convertBlocks, err = ToProviderBlocks(ctx, p, connectors, opts)
		if err != nil {
			return nil, err
		}

		if convertBlocks == nil {
			continue
		}

		blocks = append(blocks, convertBlocks...)
	}

	// Validate blocks with providers.
	ok, err := validateRequiredProviders(providers, blocks)
	if err != nil {
		return nil, err
	}

	currentProviders, err := blocks.GetProviderNames()
	if err != nil {
		return nil, err
	}

	if !ok {
		return nil, fmt.Errorf(
			"missing required providers, expected: %q, but got %q",
			stringx.Join(", ", providers...),
			stringx.Join(", ", currentProviders...),
		)
	}

	return blocks, nil
}

// ToProviderBlocks converts the connectors to blocks with provider name.
func ToProviderBlocks(ctx context.Context, provider string, connectors walruscore.Connectors, opts convertor.ConvertOptions) (block.Blocks, error) {
	var toBlockOpts convertor.Options

	switch provider {
	case TypeKubernetes, TypeHelm, TypeKubectl:
		toBlockOpts = k8s.K8sConvertorOptions{
			ConfigPath:    opts.SecretMountPath,
			ConnSeparator: opts.ConnSeparator,
		}
	default:
		toBlockOpts = opts
	}

	return LoadConvertor(provider).ToBlocks(ctx, connectors, toBlockOpts)
}

// validateRequiredProviders validate the required providers in the generated blocks.
func validateRequiredProviders(providers []string, blocks block.Blocks) (bool, error) {
	// BlockProviders is the providers of the generated blocks.
	blockProviders, err := blocks.GetProviderNames()
	if err != nil {
		return false, err
	}
	actual := sets.NewString(blockProviders...)

	// Supported is the providers which convertors can generate with the given connectors.
	// Custom providers are the providers which are generated by the primary provider.
	supported := sets.NewString(supportedProviders...)

	// Get the intersection of the required and supported providers to validate.
	required := sets.NewString(providers...)
	expected := required.Intersection(supported)

	return actual.IsSuperset(expected), nil
}
