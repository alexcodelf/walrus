package resource

import (
	"context"
	"fmt"

	"github.com/seal-io/walrus/pkg/auths/session"
	"github.com/seal-io/walrus/pkg/dao"
	"github.com/seal-io/walrus/pkg/dao/model"
	"github.com/seal-io/walrus/pkg/dao/model/resourcecomponent"
	"github.com/seal-io/walrus/pkg/dao/types/object"
	"github.com/seal-io/walrus/pkg/dao/types/status"
	deptypes "github.com/seal-io/walrus/pkg/deployer/types"
	"github.com/seal-io/walrus/utils/errorx"
	"github.com/seal-io/walrus/utils/log"
	"github.com/seal-io/walrus/utils/strs"
)

const annotationSubjectIDName = "walrus.seal.io/subject-id"

// Options for deploy or destroy.
type Options struct {
	Deployer deptypes.Deployer
}

func Create(
	ctx context.Context,
	mc model.ClientSet,
	entity *model.Resource,
	opts Options,
) (*model.ResourceOutput, error) {
	err := mc.WithTx(ctx, func(tx *model.Tx) (err error) {
		// TODO(thxCode): generated by entc.
		status.ResourceStatusDeployed.Unknown(entity, "")
		entity.Status.SetSummary(status.WalkResource(&entity.Status))

		entity, err = tx.Resources().Create().
			Set(entity).
			SaveE(ctx, dao.ResourceDependenciesEdgeSave)

		return err
	})
	if err != nil {
		return nil, err
	}

	ready, err := CheckDependencyStatus(ctx, mc, entity)
	if err != nil {
		return nil, err
	}

	// Resource dependency ready can be applied promptly.
	if ready {
		// Deploy resource.
		err = Apply(ctx, mc, entity, opts)
		if err != nil {
			return nil, err
		}
	}

	return model.ExposeResource(entity), nil
}

func UpdateStatus(
	ctx context.Context,
	mc model.ClientSet,
	entity *model.Resource,
) error {
	entity.Status.SetSummary(status.WalkResource(&entity.Status))

	err := mc.Resources().UpdateOne(entity).
		SetStatus(entity.Status).
		Exec(ctx)
	if err != nil && !model.IsNotFound(err) {
		return err
	}

	return nil
}

func Apply(
	ctx context.Context,
	mc model.ClientSet,
	entity *model.Resource,
	opts Options,
) (err error) {
	logger := log.WithName("resource")

	if !status.ResourceStatusDeployed.IsUnknown(entity) {
		return errorx.Errorf("resource status is not deploying, resource: %s", entity.ID)
	}

	err = opts.Deployer.Apply(ctx, entity, deptypes.ApplyOptions{})
	if err != nil {
		err = fmt.Errorf("failed to apply resource: %w", err)
		logger.Error(err)

		// Update a failure status.
		status.ResourceStatusDeployed.False(entity, err.Error())

		err = UpdateStatus(ctx, mc, entity)
		if err != nil {
			logger.Errorf("error updating status of resource %s: %v", entity.ID, err)
		}
	}

	return nil
}

func Destroy(
	ctx context.Context,
	mc model.ClientSet,
	entity *model.Resource,
	opts Options,
) (err error) {
	logger := log.WithName("resource")

	// If no resource component exists, skip calling deployer destroy and do straight deletion.
	exist, err := mc.ResourceComponents().Query().
		Where(resourcecomponent.ResourceID(entity.ID)).
		Exist(ctx)
	if err != nil {
		return err
	}

	if !exist {
		return mc.Resources().DeleteOneID(entity.ID).Exec(ctx)
	}

	// Check dependants.
	dependants, err := dao.GetResourceDependantNames(ctx, mc, entity)
	if err != nil {
		updateFailedStatus(ctx, mc, entity, status.ResourceStatusDeleted, err)
		return err
	}

	if len(dependants) > 0 {
		msg := fmt.Sprintf("Waiting for dependants to be deleted: %s", strs.Join(", ", dependants...))
		if !status.ResourceStatusProgressing.IsUnknown(entity) ||
			status.ResourceStatusDeleted.GetMessage(entity) != msg {
			// Mark status to deleting with dependency message.
			status.ResourceStatusDeleted.Reset(entity, msg)
			status.ResourceStatusProgressing.Unknown(entity, "")

			if err = UpdateStatus(ctx, mc, entity); err != nil {
				return fmt.Errorf("failed to update resource status: %w", err)
			}
		}

		return nil
	} else {
		// Mark status to deleting.
		status.ResourceStatusDeleted.Reset(entity, "")
		status.ResourceStatusProgressing.True(entity, "Resolved dependencies")

		if err = UpdateStatus(ctx, mc, entity); err != nil {
			return fmt.Errorf("failed to update resource status: %w", err)
		}
	}

	err = opts.Deployer.Destroy(ctx, entity, deptypes.DestroyOptions{})
	if err != nil {
		logger.Errorf("fail to destroy resource: %w", err)

		updateFailedStatus(ctx, mc, entity, status.ResourceStatusDeleted, err)
	}

	return nil
}

// Stop stops given resource.
func Stop(
	ctx context.Context,
	mc model.ClientSet,
	entity *model.Resource,
	opts Options,
) (err error) {
	logger := log.WithName("resource")

	// Check dependants.
	dependants, err := dao.GetResourceDependantNames(ctx, mc, entity, status.ResourceStatusStopped.String())
	if err != nil {
		updateFailedStatus(ctx, mc, entity, status.ResourceStatusStopped, err)
		return err
	}

	if len(dependants) > 0 {
		msg := fmt.Sprintf("Waiting for dependants to be stopped: %s", strs.Join(", ", dependants...))
		if !status.ResourceStatusProgressing.IsUnknown(entity) ||
			status.ResourceStatusStopped.GetMessage(entity) != msg {
			// Mark status to stopping with dependency message.
			status.ResourceStatusStopped.Reset(entity, "")
			status.ResourceStatusProgressing.Unknown(entity, msg)

			if err = UpdateStatus(ctx, mc, entity); err != nil {
				return fmt.Errorf("failed to update resource status: %w", err)
			}
		}

		return nil
	} else {
		// Mark status to stopping.
		status.ResourceStatusStopped.Reset(entity, "")
		status.ResourceStatusProgressing.True(entity, "Resolved dependencies")

		if err = UpdateStatus(ctx, mc, entity); err != nil {
			return fmt.Errorf("failed to update resource status: %w", err)
		}
	}

	err = opts.Deployer.Destroy(ctx, entity, deptypes.DestroyOptions{})
	if err != nil {
		logger.Errorf("fail to destroy resource: %w", err)

		updateFailedStatus(ctx, mc, entity, status.ResourceStatusStopped, err)
	}

	return nil
}

func Sync(
	ctx context.Context,
	mc model.ClientSet,
	entity *model.Resource,
	opts Options,
) (err error) {
	logger := log.WithName("resource")

	// Mark status to syncing.
	status.ResourceStatusSynced.Reset(entity, "")

	if err = UpdateStatus(ctx, mc, entity); err != nil {
		return fmt.Errorf("failed to update resource status: %w", err)
	}

	err = opts.Deployer.Sync(ctx, entity, deptypes.SyncOptions{})
	if err != nil {
		logger.Errorf("fail to sync resource: %w", err)

		updateFailedStatus(ctx, mc, entity, status.ResourceStatusSynced, err)
	}

	return nil
}

func Detect(
	ctx context.Context,
	mc model.ClientSet,
	entity *model.Resource,
	opts Options,
) (err error) {
	logger := log.WithName("resource")

	// Mark status to detecting.
	status.ResourceStatusDetected.Reset(entity, "")

	if err = UpdateStatus(ctx, mc, entity); err != nil {
		return fmt.Errorf("failed to update resource status: %w", err)
	}

	err = opts.Deployer.Detect(ctx, entity, deptypes.DetectOptions{})
	if err != nil {
		logger.Errorf("fail to detect resource: %w", err)

		updateFailedStatus(ctx, mc, entity, status.ResourceStatusDetected, err)
	}

	return nil
}

func GetSubjectID(entity *model.Resource) (object.ID, error) {
	if entity == nil {
		return "", fmt.Errorf("resource is nil")
	}

	subjectIDStr := entity.Annotations[annotationSubjectIDName]

	return object.ID(subjectIDStr), nil
}

func SetSubjectID(ctx context.Context, resources ...*model.Resource) error {
	sj, err := session.GetSubject(ctx)
	if err != nil {
		return err
	}

	for i := range resources {
		if resources[i].Annotations == nil {
			resources[i].Annotations = make(map[string]string)
		}
		resources[i].Annotations[annotationSubjectIDName] = string(sj.ID)
	}

	return nil
}

// SetResourceStatusScheduled sets the status of the resources to scheduled.
func SetResourceStatusScheduled(ctx context.Context, mc model.ClientSet, entities ...*model.Resource) error {
	for i := range entities {
		if entities[i] == nil {
			return fmt.Errorf("resource is nil")
		}
		dependencyNames := dao.ResourceRelationshipGetDependencyNames(entities[i])

		msg := ""
		if len(dependencyNames) > 0 {
			msg = fmt.Sprintf("Waiting for dependent resources to be ready: %s", strs.Join(", ", dependencyNames...))
		}

		status.ResourceStatusProgressing.Reset(entities[i], msg)
		entities[i].Status.SetSummary(status.WalkResource(&entities[i].Status))

		if err := mc.Resources().UpdateOne(entities[i]).
			SetStatus(entities[i].Status).
			Exec(ctx); err != nil {
			return err
		}
	}

	return nil
}

// CreateDraftResources creates undeployed resources but do no deployment.
// TODO refactor and coordinate with CreateScheduledResources.
func CreateDraftResources(
	ctx context.Context,
	mc model.ClientSet,
	entities ...*model.Resource,
) (model.Resources, error) {
	results := make(model.Resources, 0, len(entities))

	sortedResources, err := TopologicalSortResources(entities)
	if err != nil {
		return nil, err
	}

	err = mc.WithTx(ctx, func(tx *model.Tx) error {
		for i := range sortedResources {
			entity := sortedResources[i]

			status.ResourceStatusUnDeployed.True(entity, "Draft")
			entity.Status.SetSummary(status.WalkResource(&entity.Status))

			entity, err = tx.Resources().Create().
				Set(entity).
				SaveE(ctx, dao.ResourceDependenciesEdgeSave)
			if err != nil {
				return err
			}

			results = append(results, entity)
		}

		return nil
	})
	if err != nil {
		return nil, err
	}

	return results, nil
}

// CreateScheduledResources creates scheduled resources.
func CreateScheduledResources(
	ctx context.Context,
	mc model.ClientSet,
	entities model.Resources,
) (model.Resources, error) {
	results := make(model.Resources, 0, len(entities))

	sortedResources, err := TopologicalSortResources(entities)
	if err != nil {
		return nil, err
	}

	for i := range sortedResources {
		entity := sortedResources[i]

		err = mc.WithTx(ctx, func(tx *model.Tx) error {
			// TODO(thxCode): generated by entc.
			status.ResourceStatusDeployed.Unknown(entity, "")
			entity.Status.SetSummary(status.WalkResource(&entity.Status))

			entity, err = tx.Resources().Create().
				Set(entity).
				SaveE(ctx, dao.ResourceDependenciesEdgeSave)
			if err != nil {
				return err
			}

			return SetResourceStatusScheduled(ctx, tx, entity)
		})
		if err != nil {
			return nil, err
		}

		results = append(results, entity)
	}

	return results, nil
}

func updateFailedStatus(
	ctx context.Context,
	mc model.ClientSet,
	entity *model.Resource,
	status status.ConditionType,
	failErr error,
) {
	logger := log.WithName("resource")

	status.False(entity, failErr.Error())

	err := UpdateStatus(ctx, mc, entity)
	if err != nil {
		logger.Errorf("error updating status of resource %s: %v", entity.ID, err)
	}
}
