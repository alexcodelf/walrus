// SPDX-FileCopyrightText: 2024 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "walrus". DO NOT EDIT.

package model

import (
	"context"
	"errors"
	"fmt"

	"github.com/seal-io/walrus/pkg/dao/model/resourcestate"
	"github.com/seal-io/walrus/pkg/dao/types/object"
	"github.com/seal-io/walrus/utils/json"
)

// ResourceStateCreateInput holds the creation input of the ResourceState entity,
// please tags with `path:",inline" json:",inline"` if embedding.
type ResourceStateCreateInput struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Resource indicates to create ResourceState entity MUST under the Resource route.
	Resource *ResourceQueryInput `path:",inline" query:"-" json:"-"`
}

// Model returns the ResourceState entity for creating,
// after validating.
func (rsci *ResourceStateCreateInput) Model() *ResourceState {
	if rsci == nil {
		return nil
	}

	_rs := &ResourceState{}

	if rsci.Resource != nil {
		_rs.ResourceID = rsci.Resource.ID
	}

	return _rs
}

// Validate checks the ResourceStateCreateInput entity.
func (rsci *ResourceStateCreateInput) Validate() error {
	if rsci == nil {
		return errors.New("nil receiver")
	}

	return rsci.ValidateWith(rsci.inputConfig.Context, rsci.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceStateCreateInput entity with the given context and client set.
func (rsci *ResourceStateCreateInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rsci == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	// Validate when creating under the Resource route.
	if rsci.Resource != nil {
		if err := rsci.Resource.ValidateWith(ctx, cs, cache); err != nil {
			return err
		}
	}

	return nil
}

// ResourceStateCreateInputs holds the creation input item of the ResourceState entities.
type ResourceStateCreateInputsItem struct {
}

// ValidateWith checks the ResourceStateCreateInputsItem entity with the given context and client set.
func (rsci *ResourceStateCreateInputsItem) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rsci == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	return nil
}

// ResourceStateCreateInputs holds the creation input of the ResourceState entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type ResourceStateCreateInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Resource indicates to create ResourceState entity MUST under the Resource route.
	Resource *ResourceQueryInput `path:",inline" query:"-" json:"-"`

	// Items holds the entities to create, which MUST not be empty.
	Items []*ResourceStateCreateInputsItem `path:"-" query:"-" json:"items"`
}

// Model returns the ResourceState entities for creating,
// after validating.
func (rsci *ResourceStateCreateInputs) Model() []*ResourceState {
	if rsci == nil || len(rsci.Items) == 0 {
		return nil
	}

	_rss := make([]*ResourceState, len(rsci.Items))

	for i := range rsci.Items {
		_rs := &ResourceState{}

		if rsci.Resource != nil {
			_rs.ResourceID = rsci.Resource.ID
		}

		_rss[i] = _rs
	}

	return _rss
}

// Validate checks the ResourceStateCreateInputs entity .
func (rsci *ResourceStateCreateInputs) Validate() error {
	if rsci == nil {
		return errors.New("nil receiver")
	}

	return rsci.ValidateWith(rsci.inputConfig.Context, rsci.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceStateCreateInputs entity with the given context and client set.
func (rsci *ResourceStateCreateInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rsci == nil {
		return errors.New("nil receiver")
	}

	if len(rsci.Items) == 0 {
		return errors.New("empty items")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	// Validate when creating under the Resource route.
	if rsci.Resource != nil {
		if err := rsci.Resource.ValidateWith(ctx, cs, cache); err != nil {
			if !IsBlankResourceReferError(err) {
				return err
			} else {
				rsci.Resource = nil
			}
		}
	}

	for i := range rsci.Items {
		if rsci.Items[i] == nil {
			continue
		}

		if err := rsci.Items[i].ValidateWith(ctx, cs, cache); err != nil {
			return err
		}
	}

	return nil
}

// ResourceStateDeleteInput holds the deletion input of the ResourceState entity,
// please tags with `path:",inline"` if embedding.
type ResourceStateDeleteInput struct {
	ResourceStateQueryInput `path:",inline"`
}

// ResourceStateDeleteInputs holds the deletion input item of the ResourceState entities.
type ResourceStateDeleteInputsItem struct {
	// ID of the ResourceState entity.
	ID object.ID `path:"-" query:"-" json:"id"`
}

// ResourceStateDeleteInputs holds the deletion input of the ResourceState entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type ResourceStateDeleteInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Resource indicates to delete ResourceState entity MUST under the Resource route.
	Resource *ResourceQueryInput `path:",inline" query:"-" json:"-"`

	// Items holds the entities to create, which MUST not be empty.
	Items []*ResourceStateDeleteInputsItem `path:"-" query:"-" json:"items"`
}

// Model returns the ResourceState entities for deleting,
// after validating.
func (rsdi *ResourceStateDeleteInputs) Model() []*ResourceState {
	if rsdi == nil || len(rsdi.Items) == 0 {
		return nil
	}

	_rss := make([]*ResourceState, len(rsdi.Items))
	for i := range rsdi.Items {
		_rss[i] = &ResourceState{
			ID: rsdi.Items[i].ID,
		}
	}
	return _rss
}

// IDs returns the ID list of the ResourceState entities for deleting,
// after validating.
func (rsdi *ResourceStateDeleteInputs) IDs() []object.ID {
	if rsdi == nil || len(rsdi.Items) == 0 {
		return nil
	}

	ids := make([]object.ID, len(rsdi.Items))
	for i := range rsdi.Items {
		ids[i] = rsdi.Items[i].ID
	}
	return ids
}

// Validate checks the ResourceStateDeleteInputs entity.
func (rsdi *ResourceStateDeleteInputs) Validate() error {
	if rsdi == nil {
		return errors.New("nil receiver")
	}

	return rsdi.ValidateWith(rsdi.inputConfig.Context, rsdi.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceStateDeleteInputs entity with the given context and client set.
func (rsdi *ResourceStateDeleteInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rsdi == nil {
		return errors.New("nil receiver")
	}

	if len(rsdi.Items) == 0 {
		return errors.New("empty items")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	q := cs.ResourceStates().Query()

	// Validate when deleting under the Resource route.
	if rsdi.Resource != nil {
		if err := rsdi.Resource.ValidateWith(ctx, cs, cache); err != nil {
			return err
		} else {
			q.Where(
				resourcestate.ResourceID(rsdi.Resource.ID))
		}
	}

	ids := make([]object.ID, 0, len(rsdi.Items))

	for i := range rsdi.Items {
		if rsdi.Items[i] == nil {
			return errors.New("nil item")
		}

		if rsdi.Items[i].ID != "" {
			ids = append(ids, rsdi.Items[i].ID)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	if len(ids) != cap(ids) {
		return errors.New("found unrecognized item")
	}

	idsCnt, err := q.Where(resourcestate.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != cap(ids) {
		return errors.New("found unrecognized item")
	}

	return nil
}

// ResourceStatePatchInput holds the patch input of the ResourceState entity,
// please tags with `path:",inline" json:",inline"` if embedding.
type ResourceStatePatchInput struct {
	ResourceStateQueryInput `path:",inline" query:"-" json:"-"`

	// State data of the resource.
	Data string `path:"-" query:"-" json:"data,omitempty"`

	patchedEntity *ResourceState `path:"-" query:"-" json:"-"`
}

// PatchModel returns the ResourceState partition entity for patching.
func (rspi *ResourceStatePatchInput) PatchModel() *ResourceState {
	if rspi == nil {
		return nil
	}

	_rs := &ResourceState{
		Data: rspi.Data,
	}

	if rspi.Resource != nil {
		_rs.ResourceID = rspi.Resource.ID
	}

	return _rs
}

// Model returns the ResourceState patched entity,
// after validating.
func (rspi *ResourceStatePatchInput) Model() *ResourceState {
	if rspi == nil {
		return nil
	}

	return rspi.patchedEntity
}

// Validate checks the ResourceStatePatchInput entity.
func (rspi *ResourceStatePatchInput) Validate() error {
	if rspi == nil {
		return errors.New("nil receiver")
	}

	return rspi.ValidateWith(rspi.inputConfig.Context, rspi.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceStatePatchInput entity with the given context and client set.
func (rspi *ResourceStatePatchInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if cache == nil {
		cache = map[string]any{}
	}

	if err := rspi.ResourceStateQueryInput.ValidateWith(ctx, cs, cache); err != nil {
		return err
	}

	q := cs.ResourceStates().Query()

	// Validate when querying under the Resource route.
	if rspi.Resource != nil {
		if err := rspi.Resource.ValidateWith(ctx, cs, cache); err != nil {
			return err
		} else {
			q.Where(
				resourcestate.ResourceID(rspi.Resource.ID))
		}
	}

	if rspi.Refer != nil {
		if rspi.Refer.IsID() {
			q.Where(
				resourcestate.ID(rspi.Refer.ID()))
		} else {
			return errors.New("invalid identify refer of resourcestate")
		}
	} else if rspi.ID != "" {
		q.Where(
			resourcestate.ID(rspi.ID))
	} else {
		return errors.New("invalid identify of resourcestate")
	}

	q.Select(
		resourcestate.WithoutFields(
			resourcestate.FieldData,
		)...,
	)

	var e *ResourceState
	{
		// Get cache from previous validation.
		queryStmt, queryArgs := q.sqlQuery(setContextOp(ctx, q.ctx, "cache")).Query()
		ck := fmt.Sprintf("stmt=%v, args=%v", queryStmt, queryArgs)
		if cv, existed := cache[ck]; !existed {
			var err error
			e, err = q.Only(ctx)
			if err != nil {
				return err
			}

			// Set cache for other validation.
			cache[ck] = e
		} else {
			e = cv.(*ResourceState)
		}
	}

	_pm := rspi.PatchModel()

	_po, err := json.PatchObject(*e, *_pm)
	if err != nil {
		return err
	}

	_obj := _po.(*ResourceState)

	rspi.patchedEntity = _obj
	return nil
}

// ResourceStateQueryInput holds the query input of the ResourceState entity,
// please tags with `path:",inline"` if embedding.
type ResourceStateQueryInput struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Resource indicates to query ResourceState entity MUST under the Resource route.
	Resource *ResourceQueryInput `path:",inline" query:"-" json:"resource"`

	// Refer holds the route path reference of the ResourceState entity.
	Refer *object.Refer `path:"resourcestate,default=" query:"-" json:"-"`
	// ID of the ResourceState entity.
	ID object.ID `path:"-" query:"-" json:"id"`
}

// Model returns the ResourceState entity for querying,
// after validating.
func (rsqi *ResourceStateQueryInput) Model() *ResourceState {
	if rsqi == nil {
		return nil
	}

	return &ResourceState{
		ID: rsqi.ID,
	}
}

// Validate checks the ResourceStateQueryInput entity.
func (rsqi *ResourceStateQueryInput) Validate() error {
	if rsqi == nil {
		return errors.New("nil receiver")
	}

	return rsqi.ValidateWith(rsqi.inputConfig.Context, rsqi.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceStateQueryInput entity with the given context and client set.
func (rsqi *ResourceStateQueryInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rsqi == nil {
		return errors.New("nil receiver")
	}

	if rsqi.Refer != nil && *rsqi.Refer == "" {
		return fmt.Errorf("model: %s : %w", resourcestate.Label, ErrBlankResourceRefer)
	}

	if cache == nil {
		cache = map[string]any{}
	}

	q := cs.ResourceStates().Query()

	// Validate when querying under the Resource route.
	if rsqi.Resource != nil {
		if err := rsqi.Resource.ValidateWith(ctx, cs, cache); err != nil {
			return err
		} else {
			q.Where(
				resourcestate.ResourceID(rsqi.Resource.ID))
		}
	}

	if rsqi.Refer != nil {
		if rsqi.Refer.IsID() {
			q.Where(
				resourcestate.ID(rsqi.Refer.ID()))
		} else {
			return errors.New("invalid identify refer of resourcestate")
		}
	} else if rsqi.ID != "" {
		q.Where(
			resourcestate.ID(rsqi.ID))
	} else {
		return errors.New("invalid identify of resourcestate")
	}

	q.Select(
		resourcestate.FieldID,
	)

	var e *ResourceState
	{
		// Get cache from previous validation.
		queryStmt, queryArgs := q.sqlQuery(setContextOp(ctx, q.ctx, "cache")).Query()
		ck := fmt.Sprintf("stmt=%v, args=%v", queryStmt, queryArgs)
		if cv, existed := cache[ck]; !existed {
			var err error
			e, err = q.Only(ctx)
			if err != nil {
				return err
			}

			// Set cache for other validation.
			cache[ck] = e
		} else {
			e = cv.(*ResourceState)
		}
	}

	rsqi.ID = e.ID
	return nil
}

// ResourceStateQueryInputs holds the query input of the ResourceState entities,
// please tags with `path:",inline" query:",inline"` if embedding.
type ResourceStateQueryInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Resource indicates to query ResourceState entity MUST under the Resource route.
	Resource *ResourceQueryInput `path:",inline" query:"-" json:"-"`
}

// Validate checks the ResourceStateQueryInputs entity.
func (rsqi *ResourceStateQueryInputs) Validate() error {
	if rsqi == nil {
		return errors.New("nil receiver")
	}

	return rsqi.ValidateWith(rsqi.inputConfig.Context, rsqi.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceStateQueryInputs entity with the given context and client set.
func (rsqi *ResourceStateQueryInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rsqi == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	// Validate when querying under the Resource route.
	if rsqi.Resource != nil {
		if err := rsqi.Resource.ValidateWith(ctx, cs, cache); err != nil {
			return err
		}
	}

	return nil
}

// ResourceStateUpdateInput holds the modification input of the ResourceState entity,
// please tags with `path:",inline" json:",inline"` if embedding.
type ResourceStateUpdateInput struct {
	ResourceStateQueryInput `path:",inline" query:"-" json:"-"`
}

// Model returns the ResourceState entity for modifying,
// after validating.
func (rsui *ResourceStateUpdateInput) Model() *ResourceState {
	if rsui == nil {
		return nil
	}

	_rs := &ResourceState{
		ID: rsui.ID,
	}

	return _rs
}

// Validate checks the ResourceStateUpdateInput entity.
func (rsui *ResourceStateUpdateInput) Validate() error {
	if rsui == nil {
		return errors.New("nil receiver")
	}

	return rsui.ValidateWith(rsui.inputConfig.Context, rsui.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceStateUpdateInput entity with the given context and client set.
func (rsui *ResourceStateUpdateInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if cache == nil {
		cache = map[string]any{}
	}

	if err := rsui.ResourceStateQueryInput.ValidateWith(ctx, cs, cache); err != nil {
		return err
	}

	return nil
}

// ResourceStateUpdateInputs holds the modification input item of the ResourceState entities.
type ResourceStateUpdateInputsItem struct {
	// ID of the ResourceState entity.
	ID object.ID `path:"-" query:"-" json:"id"`
}

// ValidateWith checks the ResourceStateUpdateInputsItem entity with the given context and client set.
func (rsui *ResourceStateUpdateInputsItem) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rsui == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	return nil
}

// ResourceStateUpdateInputs holds the modification input of the ResourceState entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type ResourceStateUpdateInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Resource indicates to update ResourceState entity MUST under the Resource route.
	Resource *ResourceQueryInput `path:",inline" query:"-" json:"-"`

	// Items holds the entities to create, which MUST not be empty.
	Items []*ResourceStateUpdateInputsItem `path:"-" query:"-" json:"items"`
}

// Model returns the ResourceState entities for modifying,
// after validating.
func (rsui *ResourceStateUpdateInputs) Model() []*ResourceState {
	if rsui == nil || len(rsui.Items) == 0 {
		return nil
	}

	_rss := make([]*ResourceState, len(rsui.Items))

	for i := range rsui.Items {
		_rs := &ResourceState{
			ID: rsui.Items[i].ID,
		}

		_rss[i] = _rs
	}

	return _rss
}

// IDs returns the ID list of the ResourceState entities for modifying,
// after validating.
func (rsui *ResourceStateUpdateInputs) IDs() []object.ID {
	if rsui == nil || len(rsui.Items) == 0 {
		return nil
	}

	ids := make([]object.ID, len(rsui.Items))
	for i := range rsui.Items {
		ids[i] = rsui.Items[i].ID
	}
	return ids
}

// Validate checks the ResourceStateUpdateInputs entity.
func (rsui *ResourceStateUpdateInputs) Validate() error {
	if rsui == nil {
		return errors.New("nil receiver")
	}

	return rsui.ValidateWith(rsui.inputConfig.Context, rsui.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceStateUpdateInputs entity with the given context and client set.
func (rsui *ResourceStateUpdateInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rsui == nil {
		return errors.New("nil receiver")
	}

	if len(rsui.Items) == 0 {
		return errors.New("empty items")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	q := cs.ResourceStates().Query()

	// Validate when updating under the Resource route.
	if rsui.Resource != nil {
		if err := rsui.Resource.ValidateWith(ctx, cs, cache); err != nil {
			return err
		} else {
			q.Where(
				resourcestate.ResourceID(rsui.Resource.ID))
		}
	}

	ids := make([]object.ID, 0, len(rsui.Items))

	for i := range rsui.Items {
		if rsui.Items[i] == nil {
			return errors.New("nil item")
		}

		if rsui.Items[i].ID != "" {
			ids = append(ids, rsui.Items[i].ID)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	if len(ids) != cap(ids) {
		return errors.New("found unrecognized item")
	}

	idsCnt, err := q.Where(resourcestate.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != cap(ids) {
		return errors.New("found unrecognized item")
	}

	for i := range rsui.Items {
		if err := rsui.Items[i].ValidateWith(ctx, cs, cache); err != nil {
			return err
		}
	}

	return nil
}

// ResourceStateOutput holds the output of the ResourceState entity.
type ResourceStateOutput struct {
	ID object.ID `json:"id,omitempty"`

	Resource *ResourceOutput `json:"resource,omitempty"`
}

// View returns the output of ResourceState entity.
func (_rs *ResourceState) View() *ResourceStateOutput {
	return ExposeResourceState(_rs)
}

// View returns the output of ResourceState entities.
func (_rss ResourceStates) View() []*ResourceStateOutput {
	return ExposeResourceStates(_rss)
}

// ExposeResourceState converts the ResourceState to ResourceStateOutput.
func ExposeResourceState(_rs *ResourceState) *ResourceStateOutput {
	if _rs == nil {
		return nil
	}

	rso := &ResourceStateOutput{
		ID: _rs.ID,
	}

	if _rs.Edges.Resource != nil {
		rso.Resource = ExposeResource(_rs.Edges.Resource)
	} else if _rs.ResourceID != "" {
		rso.Resource = &ResourceOutput{
			ID: _rs.ResourceID,
		}
	}
	return rso
}

// ExposeResourceStates converts the ResourceState slice to ResourceStateOutput pointer slice.
func ExposeResourceStates(_rss []*ResourceState) []*ResourceStateOutput {
	if len(_rss) == 0 {
		return nil
	}

	rsos := make([]*ResourceStateOutput, len(_rss))
	for i := range _rss {
		rsos[i] = ExposeResourceState(_rss[i])
	}
	return rsos
}
